#pragma config(Sensor, dgtl1,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port2,           leftMotor,     tmotorVex393_MC29, PIDControl, reversed, driveLeft, encoderPort, dgtl1)
#pragma config(Motor,  port3,           rightMotor,    tmotorVex393_MC29, PIDControl, driveRight, encoderPort, dgtl3)
#pragma config(Motor,  port4,           hMotor,        tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Storing Constants for Wheel Diameter and Pi
#define wheelDiameter 4
#define Pi 3.14

#define abs(X) ((X < 0) ? -1 * X : X)
#define MAX_POWER_OUT										127
#define MIN_POWER_OUT								  	-127

int tickGoal;
int driveCoeff = 0.5;

int limitMotorPower(int power)																														//
{																																													//
	int	outputPower;																																				//
																																													//
	outputPower = power;																																		//
	if(outputPower > MAX_POWER_OUT)																													//
	{																																												//
		outputPower = MAX_POWER_OUT;																													//
	}																																												//
	else if(outputPower < MIN_POWER_OUT)																										//
	{																																												//
		outputPower = MIN_POWER_OUT;																													//
	}																																												//
	return(outputPower);																																		//
}

void driveForwardP(int tenthsOfIn)
{
	SensorValue[leftEncoder] = 0; // It is good practice to reset encoder values at the start of a function.
	SensorValue[rightEncoder] = 0;

	float wheelCircumference = wheelDiameter*Pi;
	int ticks = 360/wheelCircumference;
	int tickGoal = (ticks * tenthsOfIn) / 10;

	int leftError;
	int leftPower;

	int rightError;
	int rightPower;
	while((abs(SensorValue[leftEncoder]) < tickGoal)||(abs(SensorValue[leftEncoder]) < tickGoal))
	{
		leftError = (tickGoal - SensorValue[leftEncoder]);
		leftPower = (leftError * driveCoeff);
		leftPower = limitMotorPower(leftPower);
		motor[leftMotor] = leftPower;

		rightError = (tickGoal - SensorValue[rightEncoder]);
		rightPower = (rightError * driveCoeff);
		rightPower = limitMotorPower(rightPower);
		motor[rightMotor] = rightPower;
	}

	motor[leftMotor] = 0;  // stop motors
	motor[rightMotor] = 0;
}

//Drive Forward with Target in Inches (Built in PID)
void driveForward(float target)
{
	float wheelCircumference = wheelDiameter*Pi;
	int ticks = 360/wheelCircumference;
	tickGoal = ticks * target;

	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);

	setMotorTarget(leftMotor,ticks,127,true);
	setMotorTarget(rightMotor,ticks,127,true);
	//moveMotorTarget(leftMotor,ticks,127,true);
	//moveMotorTarget(rightMotor,ticks,127,true);

	while ((!getMotorTargetCompleted(leftMotor))||!getMotorTargetCompleted(rightMotor)) // wait for both motors to reach idle
	{ // idle loop, except to display encoder values
		wait1Msec(100);
	}

	motor[leftMotor] = 0;  // stop motors
	motor[rightMotor] = 0;

	wait1Msec(2000); // used to read final encoder values on screen before ending program
}

task main()
{
	driveForward(10);
	wait1Msec(100);
}
